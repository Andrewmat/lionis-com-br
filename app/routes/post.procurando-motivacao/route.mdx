---
title: Procurando a motiva√ß√£o
published: true
publishDate: 2023-10-07 18:51:00 -0300
description: Uma pequena cole√ß√£o de hist√≥rias pessoais sobre como entender o objetivo da tarefa ajuda a executarmos ela melhor
tags: [discuss, programming, braziliandevs]
summary: |
  A gente come√ßa os nossos passos seguindo as regras.
  A gente vai aprendendo, e revemos essas regras.
  No final, porque essas regras existem?
---
import { getMeta, getLoader , PostHeader } from '~/lib/mdx-utils';

export const loader = getLoader(frontmatter);
export const meta = getMeta(frontmatter);

<PostHeader {...frontmatter} />

Esse post n√£o √© sobre c√≥digo. Mesmo se n√£o souber programar, voc√™ n√£o deve ter dificuldades em acompanhar üòÑ

---

Eu j√° ouvi bastante feedback no meu trabalho. O mais constante sendo melhorias de comunica√ß√£o, que at√© hoje tenho certo problema. 

Um problema que ocorria frequentemente era que as minhas explica√ß√µes que eram muito t√©cnicas. Na minha conversa com o time de produto isso complicava tudo. Por exemplo, eu explicava todo o contexto por volta de uma nova implementa√ß√£o de feature. Levantava as possibilidades que conseguia pensar, trazendo as facilidades e dificuldades que trariam na implementa√ß√£o inicial e na manuten√ß√£o do c√≥digo. Eu estava pensando comigo mesmo e sendo transparente com todo mundo.

Isso era relevante se fosse discutir com pessoas mais seniores, mas raramente era o caso. O que aprendi com o tempo era entender o escopo do que as pessoas *precisavam* saber, e trazer isso a elas. Entender o porqu√™ daquela comunica√ß√£o existir, e relevar o que exatamente eu precisava comunicar de acordo com esse motivo.

Aplicando isso, as mensagens de Slack que eram 5 par√°grafos gigantes explicando os pormenores da entrega viravam 5 frases breves focando no que a pessoa precisava saber. Pra escrever as 5 frases eu ainda demoro, mas a comunica√ß√£o fica bem mais flu√≠da assim.

---

Eu lembro quando eu criava testes de componentes React usando Enzyme. Foi √≥timo aprender o mundo frontend com ele, porque eram simples, e qualquer um poderia criar testes sem esfor√ßo.

```js
it('renders', () => {
  const wrapper = shallow(<Component />);
  expect(wrapper).toMatchSnapshot();
})
```

Eu gosto de pensar nesses testes como "snacks", eles s√£o r√°pidos de serem escritos e entendidos, e raramente quebram. Se quebrar, era um processo simples corrigir eles, geralmente eu apertava U no teclado e o snapshot atualizava sozinho, eu nem precisava verificar.

Mas uma coisa que ficava escondida para mim era que os testes, sendo f√°ceis de serem mantidos, eram tamb√©m *muito* in√∫teis. Muitos bugs passavam nesse m√©todo, e no final o valor dos testes era bem limitado.

React Testing Library chega na minha vida. Ela vem com um princ√≠pio:

> The more your tests resemble the way your software is used, the more confidence they can give you.

Essa pequena frase afeta bastante. Para seguir esse princ√≠pio, a React Testing Library tem **menos** possibilidades do que a Enzyme, mas o que pra mim parecia um detrator da lib acabava sendo uma vantagem. Isso diminui o foco na estrutura do c√≥digo, e aumenta o foco no usu√°rio como valor principal dos testes.

Eu s√≥ fazia testes porque era considerado boa pr√°tica, mas nenhum momento eu tinha pensado em um Objetivo dos testes, que colocava valor nos testes em si. Eu nem precisava da React Testing Library pra aplicar esse princ√≠pio. Ao me restringir dentro do Enzyme, eu criava testes com mais valor.

---

## Questione o natural

DRY (*Don't Repeat Yourself* ou *N√£o Se Repita*) √© um acr√¥nimo bem popular de boa pr√°tica no mundo da programa√ß√£o. A ideia dele √© reduzir retrabalho com a regra de n√£o duplicar c√≥digo.

Essa regra √© aplicada n√£o s√≥ no frontend, mas em todos os n√≠veis de programa√ß√£o que j√° vi. E de longe √© a mais popular e mais implementada por times. Uma cr√≠tica recente a essa "boa pr√°tica" √© que ela introduz c√≥digos complexos demais com o tempo.

O processo acaba sendo o seguinte: uma pessoa evita repetir o c√≥digo introduzindo uma abstra√ß√£o. Outra pessoa, considerando que precisa dessa abstra√ß√£o, usa ela e altera pro seu caso. E mais uma pessoa, e outra, assim vai indo. At√© que a abstra√ß√£o n√£o faz mais sentido, mas √© utilizada por todos.

Outras regras foram introduzidas para mitigar esse problema. WET (*Write Everything Twice* ou *Escreva Tudo Duas Vezes*) √© uma regra que diz: "Todo c√≥digo deve ser escrito no m√°ximo duas vezes". √â uma regra que mitiga esses problemas, mas ao meu ver tem outra regra, ou melhor, ideia, que diminui a complexidade de c√≥digo, o [AHA](https://dev.to/cher/avoiding-hasty-abstractions-aha-programming-3d3b): "Avoid Hasty Abstractions" (ou Evite Abstra√ß√µes Apressadas).

A ideia do AHA programming √© introduzir abstra√ß√µes no c√≥digo quando elas forem necess√°rias, e diminuir o uso de abstra√ß√µes simplesmente por abstrair.

A vantagem (e desvantagem) do AHA √© que ele n√£o d√° uma regra f√°cil de ser seguida. Ele abre m√£o de uma regra definida para que a pessoa desenvolvendo consiga determinar v√°rios fatores que definam se tal abstra√ß√£o √© necess√°ria. Isso faz com que alguns casos apare√ßam meio estranhos, por exemplo:

```js
const DEBUG_QUERY_PARAM = 'shouldDebug'

function Component() {
  const { search } = useLocation()
  // ...

  const doSomething = () => {
    const shouldDebug = new URLQueryParams(location.search)
        .has(DEBUG_QUERY_PARAM);
    if (shouldDebug) {
      console.log('debugging happening');
    }
    // ...
  }
}
```

Esse c√≥digo tem duas abstra√ß√µes relevantes: `DEBUG_QUERY_PARAM` e `shouldDebug`. Ambas existem mas s√≥ s√£o utilizadas uma vez.

Se for se basear s√≥ nas regras de DRY ou WET, ambas as abstra√ß√µes n√£o fazem sentido, elas est√£o sendo usadas s√≥ uma vez no c√≥digo. Mas √© importante capturar o prop√≥sito real por traz delas antes de remov√™-las.

`DEBUG_QUERY_PARAM` tem uma valor de documentar o comportamento. Ele informa pra quem est√° lendo que existe uma fun√ß√£o de debug do c√≥digo, e ele √© controlado pela query param `shouldDebug`. A inten√ß√£o do c√≥digo n√£o √© reuso, mas sim documenta√ß√£o de uma feature.

`shouldDebug` tem o prop√≥sito de abstrair um c√≥digo complexo em um c√≥digo f√°cil de ser entendido por um humano, pode inclusive ensinar atrav√©s dessa interface amig√°vel. Al√©m disso, ele representa melhor a inten√ß√£o da pessoa que o criou, fazendo o trabalho de manuten√ß√£o mais f√°cil caso haja algum bug.

> ‚ö†Ô∏è Eu n√£o estou necessariamente dizendo que o c√≥digo escrito √© um bom c√≥digo. Leve em conta o contexto dele antes de aplicar o mesmo racional.

## Por qu√™?

Essas historietas est√£o conectadas por uma ideia, sintetizada por uma/duas palavra(s): "Por qu√™?" Pra trazer valor em uma tarefa, eu preciso entender o motivo dela.

J√° vi uma t√©cnica chamada "Os 5 porqu√™s", criada com o objetivo de chegar √† raiz do problema. Nela, voc√™ entra numa recurs√£o: pergunta o motivo de um problema ocorrer, e depois disso procura explicar porque esse motivo existe, e continuamente. 

Essa t√©cnica pode ser aplicada onde voc√™ ainda n√£o enxerga problemas. Tente entender a motiva√ß√£o por tr√°s. Essa motiva√ß√£o n√£o precisa ser a melhor do mundo, mas tem que ser sincera. Se voc√™ quer usar TypeScript inv√©s de JS, voc√™ n√£o precisa falar que tem mais qualidade ou os mesmos argumentos de sempre. Os argumentos podem ser baseados no seu contexto: talvez voc√™ queira experimentar TS no seu projeto, ou voc√™ queira melhorar seu portif√≥lio profissional.

## *Post Scriptum*

Sendo um pouco meta aqui e aplicando o post no pr√≥prio. Eu j√° tentei escrever muito, mas nunca terminei de escrever. Falei sobre esse assunto no post porque √© um assunto que tenho muito o que falar, o que facilita a escrever. E no final, quero escrever posts como esse como parte da minha vida profissional.
